# Use composites

Composites allow modules to inject content into predefined slots inside components.

Pattern:
1. Define slots in components (for example a toolbar with named slots).
2. Modules register content for those slots via a composite API.
3. At render time, the component renders core content plus registered composite contributions.

Use cases:
- Add buttons or menu items to shared toolbars.
- Let modules append content to a shared page layout.

Guidelines:
- Use meaningful slot names and keep composites loosely coupled to maintain flexibility.

## What composites are

Suppose you have a list of React.js components you render. You would like that list's content to be enriched by other modules. This is the purpose of composites.

A composite is a React component whose content can be extended by modules while remaining compatible with bundlers (Vite.js/WebPack, and especially Jopi's internal bundler).

## Why use composites?

Compatibility with bundlers is the main challenge for this pattern: bundler pruning can introduce confusing anomalies, or you may be forced to pre-load code that gets included even where it is not needed.

Jopi provides a pattern designed to implement this system elegantly and compatibly.

## Creating a composite

Composites are declared statically, similar to the event system described earlier. Each module can enrich an existing composite.

```
|- mod_moduleA/
 |- @alias/
  |- uiComposites/       < Where our composites are declared
   |- comp1              < The name for the composite
	  |- a1              < Names determine the composites order (sorted ASC)
	     |- index.tsx    < Export the React component
      |- a2
      |- a3
|- mod_moduleB/
 |- @alias/
  |- uiComposites/
   |- comp1                < moduleB will extend our composite
      |- a2b               < Here we add an item to the list (4th position)
	  |- a1                < The name indicates list item order
	     |- index.tsx      <   but also allows overriding an existing element.
	     |- high.priority  < This priority indicates who overrides whom.
```

As shown, it's possible to override a component with the same name. To do so, the overriding item must have a higher priority than the item being overridden. The default priority is `default.priority`.

## Using a composite

Using a composite is simple. Here is an example for the composite created above.

```typescript tsx
import MyComposite from "@/uiComposites/comp1";

export default function() {
    return <MyComposite />
}
```

Here, the MyComposite component includes the elements a1, a2, a2b and a3 in the indicated order.

> If you inspect the code generated by the bundler, you'll see everything is optimized so that no part of MyComposite is included if MyComposite is not used.
